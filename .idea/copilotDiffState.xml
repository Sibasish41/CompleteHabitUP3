<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/HabitUP-master/src/services/achievementService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HabitUP-master/src/services/achievementService.js" />
              <option name="originalContent" value="import axios from 'axios';&#10;&#10;const API_BASE_URL = '/api/achievements';&#10;&#10;export const getUserAchievements = async () =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}`, { withCredentials: true });&#10;  return response.data.data;&#10;};&#10;&#10;export const checkAchievement = async (achievementId) =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}/${achievementId}/check`, { withCredentials: true });&#10;  return response.data.data;&#10;};" />
              <option name="updatedContent" value="import axios from 'axios';&#10;&#10;const API_BASE_URL = '/api/achievements';&#10;&#10;export const getUserAchievements = async () =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}`, { withCredentials: true });&#10;  return response.data.data;&#10;};&#10;&#10;export const checkAchievement = async (achievementId) =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}/${achievementId}/check`, { withCredentials: true });&#10;  return response.data.data;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HabitUP-master/src/services/habitService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HabitUP-master/src/services/habitService.js" />
              <option name="originalContent" value="import axios from 'axios';&#10;&#10;const API_BASE_URL = '/api/habit';&#10;&#10;export const getUserHabits = async () =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}/user-habits`, { withCredentials: true });&#10;  return response.data.data;&#10;};&#10;&#10;export const toggleHabitCompletion = async (habitId) =&gt; {&#10;  const response = await axios.post(`${API_BASE_URL}/${habitId}/toggle`, {}, { withCredentials: true });&#10;  return response.data.data;&#10;};&#10;&#10;export const getHabitStats = async () =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}/stats`, { withCredentials: true });&#10;  return response.data.data;&#10;};" />
              <option name="updatedContent" value="import axios from 'axios';&#10;&#10;const API_BASE_URL = '/api/habit';&#10;&#10;export const getUserHabits = async () =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}/user-habits`, { withCredentials: true });&#10;  return response.data.data;&#10;};&#10;&#10;export const toggleHabitCompletion = async (habitId) =&gt; {&#10;  const response = await axios.post(`${API_BASE_URL}/${habitId}/toggle`, {}, { withCredentials: true });&#10;  return response.data.data;&#10;};&#10;&#10;export const getHabitStats = async () =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}/stats`, { withCredentials: true });&#10;  return response.data.data;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HabitUP-master/src/services/userService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HabitUP-master/src/services/userService.js" />
              <option name="originalContent" value="import axios from 'axios';&#10;&#10;const API_BASE_URL = '/api/user';&#10;&#10;export const getUserProfile = async () =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}/profile`, { withCredentials: true });&#10;  return response.data.data;&#10;};&#10;" />
              <option name="updatedContent" value="import axios from 'axios';&#10;&#10;const API_BASE_URL = '/api/user';&#10;&#10;export const getUserProfile = async () =&gt; {&#10;  const response = await axios.get(`${API_BASE_URL}/profile`, { withCredentials: true });&#10;  return response.data.data;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HabitUPMigration247-master/controllers/userController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HabitUPMigration247-master/controllers/userController.js" />
              <option name="originalContent" value="const { User, Habit, HabitProgress, Permission } = require('../models');&#10;const { ApiError } = require('../middleware/errorHandler');&#10;const multer = require('multer');&#10;const path = require('path');&#10;const fs = require('fs').promises;&#10;const { Op } = require('sequelize');&#10;&#10;// Configure multer for file uploads&#10;const storage = multer.diskStorage({&#10;  destination: async (req, file, cb) =&gt; {&#10;    const uploadPath = 'uploads/profile_photos';&#10;    try {&#10;      await fs.mkdir(uploadPath, { recursive: true });&#10;      cb(null, uploadPath);&#10;    } catch (error) {&#10;      cb(error);&#10;    }&#10;  },&#10;  filename: (req, file, cb) =&gt; {&#10;    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);&#10;    cb(null, uniqueSuffix + path.extname(file.originalname));&#10;  }&#10;});&#10;&#10;const upload = multer({&#10;  storage,&#10;  limits: {&#10;    fileSize: 5 * 1024 * 1024 // 5MB limit&#10;  },&#10;  fileFilter: (req, file, cb) =&gt; {&#10;    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];&#10;    if (allowedTypes.includes(file.mimetype)) {&#10;      cb(null, true);&#10;    } else {&#10;      cb(new ApiError('Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed', 400));&#10;    }&#10;  }&#10;});&#10;&#10;class UserController {&#10;  // Get current user profile&#10;  async getCurrentUser(req, res, next) {&#10;    try {&#10;      const user = await User.findByPk(req.user.userId, {&#10;        include: [&#10;          {&#10;            model: Permission,&#10;            as: 'permissions',&#10;            through: { attributes: [] }&#10;          },&#10;          {&#10;            model: Habit,&#10;            as: 'habits',&#10;            through: { attributes: [] },&#10;            where: { isActive: true },&#10;            required: false&#10;          }&#10;        ]&#10;      });&#10;&#10;      if (!user) {&#10;        return next(new ApiError('User not found', 404));&#10;      }&#10;&#10;      // Exclude sensitive fields&#10;      const userData = user.toJSON();&#10;      delete userData.password;&#10;&#10;      res.json({&#10;        success: true,&#10;        data: userData&#10;      });&#10;    } catch (error) {&#10;      next(error);&#10;    }&#10;  }&#10;&#10;  // Update user profile&#10;  async updateProfile(req, res, next) {&#10;    try {&#10;      const userId = req.user.userId;&#10;      const {&#10;        name,&#10;        dob,&#10;        phoneNo,&#10;        gender&#10;      } = req.body;&#10;&#10;      const user = await User.findByPk(userId);&#10;      if (!user) {&#10;        return next(new ApiError('User not found', 404));&#10;      }&#10;&#10;      // Check if phone number is being changed and if it's already taken&#10;      if (phoneNo &amp;&amp; phoneNo !== user.phoneNo) {&#10;        const existingUser = await User.findOne({ &#10;          where: { &#10;            phoneNo,&#10;            userId: { [Op.ne]: userId }&#10;          }&#10;        });&#10;        &#10;        if (existingUser) {&#10;          return next(new ApiError('Phone number already exists', 400));&#10;        }&#10;      }&#10;&#10;      const updateData = {};&#10;      if (name) updateData.name = name;&#10;      if (dob) updateData.dob = dob;&#10;      if (phoneNo) updateData.phoneNo = phoneNo;&#10;      if (gender) updateData.gender = gender;&#10;&#10;      await user.update(updateData);&#10;&#10;      res.json({&#10;        success: true,&#10;        message: 'Profile updated successfully',&#10;        data: user&#10;      });&#10;    } catch (error) {&#10;      next(error);&#10;    }&#10;  }&#10;&#10;  // Update profile photo&#10;  async updateProfilePhoto(req, res, next) {&#10;    try {&#10;      const userId = req.user.userId;&#10;&#10;      if (!req.file) {&#10;        return next(new ApiError('No file uploaded', 400));&#10;      }&#10;&#10;      const user = await User.findByPk(userId);&#10;      if (!user) {&#10;        return next(new ApiError('User not found', 404));&#10;      }&#10;&#10;      // Convert image to base64&#10;      const imageBuffer = await fs.readFile(req.file.path);&#10;      const base64Image = `data:${req.file.mimetype};base64,${imageBuffer.toString('base64')}`;&#10;&#10;      // Update user profile photo&#10;      await user.update({ profilePhoto: base64Image });&#10;&#10;      // Delete uploaded file&#10;      await fs.unlink(req.file.path);&#10;&#10;      res.json({&#10;        success: true,&#10;        message: 'Profile photo updated successfully',&#10;        data: {&#10;          profilePhoto: base64Image&#10;        }&#10;      });&#10;    } catch (error) {&#10;      // Clean up uploaded file if error occurs&#10;      if (req.file) {&#10;        try {&#10;          await fs.unlink(req.file.path);&#10;        } catch (unlinkError) {&#10;          console.error('Error deleting uploaded file:', unlinkError);&#10;        }&#10;      }&#10;      next(error);&#10;    }&#10;  }&#10;&#10;  // Get user profile photo&#10;  async getProfilePhoto(req, res, next) {&#10;    try {&#10;      const { email } = req.params;&#10;      &#10;      const user = await User.findOne({ where: { email } });&#10;      if (!user || !user.profilePhoto) {&#10;        return next(new ApiError('Profile photo not found', 404));&#10;      }&#10;&#10;      res.json({&#10;        success: true,&#10;        data: {&#10;          profilePhoto: user.profilePhoto&#10;        }&#10;      });&#10;    } catch (error) {&#10;      next(error);&#10;    }&#10;  }&#10;&#10;  // Change password&#10;  async changePassword(req, res, next) {&#10;    try {&#10;      const userId = req.user.userId;&#10;      const { currentPassword, newPassword } = req.body;&#10;&#10;      const user = await User.findByPk(userId);&#10;      if (!user) {&#10;        return next(new ApiError('User not found', 404));&#10;      }&#10;&#10;      // Verify current password&#10;      const isCurrentPasswordValid = await user.comparePassword(currentPassword);&#10;      if (!isCurrentPasswordValid) {&#10;        return next(new ApiError('Current password is incorrect', 400));&#10;      }&#10;&#10;      // Update password&#10;      await user.update({ password: newPassword });&#10;&#10;      res.json({&#10;        success: true,&#10;        message: 'Password changed successfully'&#10;      });&#10;    } catch (error) {&#10;      next(error);&#10;    }&#10;  }&#10;&#10;  // Get user dashboard data&#10;  async getDashboard(req, res, next) {&#10;    try {&#10;      const userId = req.user.userId;&#10;      const today = new Date().toISOString().split('T')[0];&#10;&#10;      // Get user habits with today's progress&#10;      const habits = await Habit.findAll({&#10;        include: [&#10;          {&#10;            model: User,&#10;            as: 'users',&#10;            where: { userId },&#10;            attributes: [],&#10;            through: { attributes: [] }&#10;          },&#10;          {&#10;            model: HabitProgress,&#10;            as: 'progress',&#10;            where: { &#10;              userId,&#10;              completionDate: today&#10;            },&#10;            required: false&#10;          }&#10;        ],&#10;        where: { isActive: true }&#10;      });&#10;&#10;      // Calculate statistics&#10;      const totalHabits = habits.length;&#10;      const completedToday = habits.filter(h =&gt; &#10;        h.progress.length &gt; 0 &amp;&amp; h.progress[0].completionStatus === 'COMPLETED'&#10;      ).length;&#10;&#10;      // Get weekly progress&#10;      const weekAgo = new Date();&#10;      weekAgo.setDate(weekAgo.getDate() - 7);&#10;&#10;      const weeklyProgress = await HabitProgress.findAll({&#10;        where: {&#10;          userId,&#10;          completionDate: {&#10;            [Op.gte]: weekAgo.toISOString().split('T')[0]&#10;          },&#10;          completionStatus: 'COMPLETED'&#10;        },&#10;        attributes: ['completionDate'],&#10;        group: ['completionDate'],&#10;        order: [['completionDate', 'ASC']]&#10;      });&#10;&#10;      // Get current streaks&#10;      const habitStreaks = habits.map(habit =&gt; ({&#10;        habitId: habit.habitId,&#10;        habitName: habit.habitName,&#10;        currentStreak: habit.currentStreak,&#10;        longestStreak: habit.longestStreak&#10;      }));&#10;&#10;      res.json({&#10;        success: true,&#10;        data: {&#10;          habits,&#10;          statistics: {&#10;            totalHabits,&#10;            completedToday,&#10;            completionRate: totalHabits &gt; 0 ? (completedToday / totalHabits * 100).toFixed(2) : 0,&#10;            weeklyCompletions: weeklyProgress.length&#10;          },&#10;          streaks: habitStreaks&#10;        }&#10;      });&#10;    } catch (error) {&#10;      next(error);&#10;    }&#10;  }&#10;&#10;  // Get user statistics&#10;  async getStatistics(req, res, next) {&#10;    try {&#10;      const userId = req.user.userId;&#10;      const { period = '30' } = req.query;&#10;&#10;      const startDate = new Date();&#10;      startDate.setDate(startDate.getDate() - parseInt(period));&#10;&#10;      const [&#10;        totalHabits,&#10;        completedHabits,&#10;        habitProgress,&#10;        categoryStats&#10;      ] = await Promise.all([&#10;        // Total active habits&#10;        Habit.count({&#10;          include: [{&#10;            model: User,&#10;            as: 'users',&#10;            where: { userId },&#10;            through: { attributes: [] }&#10;          }],&#10;          where: { isActive: true }&#10;        }),&#10;&#10;        // Completed habits in period&#10;        HabitProgress.count({&#10;          where: {&#10;            userId,&#10;            completionDate: {&#10;              [Op.gte]: startDate.toISOString().split('T')[0]&#10;            },&#10;            completionStatus: 'COMPLETED'&#10;          }&#10;        }),&#10;&#10;        // Daily progress over period&#10;        HabitProgress.findAll({&#10;          where: {&#10;            userId,&#10;            completionDate: {&#10;              [Op.gte]: startDate.toISOString().split('T')[0]&#10;            }&#10;          },&#10;          attributes: [&#10;            'completionDate',&#10;            'completionStatus'&#10;          ],&#10;          order: [['completionDate', 'ASC']]&#10;        }),&#10;&#10;        // Habit categories statistics&#10;        Habit.findAll({&#10;          include: [{&#10;            model: User,&#10;            as: 'users',&#10;            where: { userId },&#10;            attributes: [],&#10;            through: { attributes: [] }&#10;          }],&#10;          attributes: [&#10;            'habitCategory',&#10;            'currentStreak',&#10;            'longestStreak'&#10;          ],&#10;          where: { isActive: true }&#10;        })&#10;      ]);&#10;&#10;      // Process daily progress&#10;      const dailyStats = {};&#10;      habitProgress.forEach(progress =&gt; {&#10;        const date = progress.completionDate;&#10;        if (!dailyStats[date]) {&#10;          dailyStats[date] = { completed: 0, total: 0 };&#10;        }&#10;        dailyStats[date].total++;&#10;        if (progress.completionStatus === 'COMPLETED') {&#10;          dailyStats[date].completed++;&#10;        }&#10;      });&#10;&#10;      // Process category statistics&#10;      const categoryBreakdown = {};&#10;      categoryStats.forEach(habit =&gt; {&#10;        const category = habit.habitCategory;&#10;        if (!categoryBreakdown[category]) {&#10;          categoryBreakdown[category] = {&#10;            count: 0,&#10;            totalCurrentStreak: 0,&#10;            maxStreak: 0&#10;          };&#10;        }&#10;        categoryBreakdown[category].count++;&#10;        categoryBreakdown[category].totalCurrentStreak += habit.currentStreak;&#10;        categoryBreakdown[category].maxStreak = Math.max(&#10;          categoryBreakdown[category].maxStreak,&#10;          habit.longestStreak&#10;        );&#10;      });&#10;&#10;      res.json({&#10;        success: true,&#10;        data: {&#10;          period: parseInt(period),&#10;          overview: {&#10;            totalHabits,&#10;            completedHabits,&#10;            completionRate: totalHabits &gt; 0 ? (completedHabits / (totalHabits * parseInt(period)) * 100).toFixed(2) : 0&#10;          },&#10;          dailyProgress: dailyStats,&#10;          categoryBreakdown,&#10;          generatedAt: new Date().toISOString()&#10;        }&#10;      });&#10;    } catch (error) {&#10;      next(error);&#10;    }&#10;  }&#10;&#10;  // Delete user account&#10;  async deleteAccount(req, res, next) {&#10;    try {&#10;      const userId = req.user.userId;&#10;      const { password } = req.body;&#10;&#10;      const user = await User.findByPk(userId);&#10;      if (!user) {&#10;        return next(new ApiError('User not found', 404));&#10;      }&#10;&#10;      // Verify password before deletion&#10;      const isPasswordValid = await user.comparePassword(password);&#10;      if (!isPasswordValid) {&#10;        return next(new ApiError('Password is incorrect', 400));&#10;      }&#10;&#10;      // Delete user data&#10;      await HabitProgress.destroy({ where: { userId } });&#10;      &#10;      // Remove user from habits&#10;      const userHabits = await user.getHabits();&#10;      await user.removeHabits(userHabits);&#10;&#10;      // Delete user&#10;      await user.destroy();&#10;&#10;      res.json({&#10;        success: true,&#10;        message: 'Account deleted successfully'&#10;      });&#10;    } catch (error) {&#10;      next(error);&#10;    }&#10;  }&#10;&#10;  // Export multer upload middleware&#10;  static getUploadMiddleware() {&#10;    return upload.single('profilePhoto');&#10;  }&#10;}&#10;&#10;module.exports = new UserController();&#10;" />
              <option name="updatedContent" value="const { User, Habit, HabitProgress, Permission } = require('../models');&#13;&#10;const { ApiError } = require('../middleware/errorHandler');&#13;&#10;const multer = require('multer');&#13;&#10;const path = require('path');&#13;&#10;const fs = require('fs').promises;&#13;&#10;const { Op } = require('sequelize');&#13;&#10;&#13;&#10;// Configure multer for file uploads&#13;&#10;const storage = multer.diskStorage({&#13;&#10;  destination: async (req, file, cb) =&gt; {&#13;&#10;    const uploadPath = 'uploads/profile_photos';&#13;&#10;    try {&#13;&#10;      await fs.mkdir(uploadPath, { recursive: true });&#13;&#10;      cb(null, uploadPath);&#13;&#10;    } catch (error) {&#13;&#10;      cb(error);&#13;&#10;    }&#13;&#10;  },&#13;&#10;  filename: (req, file, cb) =&gt; {&#13;&#10;    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);&#13;&#10;    cb(null, uniqueSuffix + path.extname(file.originalname));&#13;&#10;  }&#13;&#10;});&#13;&#10;&#13;&#10;const upload = multer({&#13;&#10;  storage,&#13;&#10;  limits: {&#13;&#10;    fileSize: 5 * 1024 * 1024 // 5MB limit&#13;&#10;  },&#13;&#10;  fileFilter: (req, file, cb) =&gt; {&#13;&#10;    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];&#13;&#10;    if (allowedTypes.includes(file.mimetype)) {&#13;&#10;      cb(null, true);&#13;&#10;    } else {&#13;&#10;      cb(new ApiError('Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed', 400));&#13;&#10;    }&#13;&#10;  }&#13;&#10;});&#13;&#10;&#13;&#10;class UserController {&#13;&#10;  // Get current user profile&#13;&#10;  async getCurrentUser(req, res, next) {&#13;&#10;    try {&#13;&#10;      const user = await User.findByPk(req.user.userId, {&#13;&#10;        include: [&#13;&#10;          {&#13;&#10;            model: Permission,&#13;&#10;            as: 'permissions',&#13;&#10;            through: { attributes: [] }&#13;&#10;          },&#13;&#10;          {&#13;&#10;            model: Habit,&#13;&#10;            as: 'habits',&#13;&#10;            through: { attributes: [] },&#13;&#10;            where: { isActive: true },&#13;&#10;            required: false&#13;&#10;          }&#13;&#10;        ]&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!user) {&#13;&#10;        return next(new ApiError('User not found', 404));&#13;&#10;      }&#13;&#10;&#13;&#10;      // Exclude sensitive fields&#13;&#10;      const userData = user.toJSON();&#13;&#10;      delete userData.password;&#13;&#10;&#13;&#10;      res.json({&#13;&#10;        success: true,&#13;&#10;        data: userData&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      next(error);&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  // Update user profile&#13;&#10;  async updateProfile(req, res, next) {&#13;&#10;    try {&#13;&#10;      const userId = req.user.userId;&#13;&#10;      const {&#13;&#10;        name,&#13;&#10;        dob,&#13;&#10;        phoneNo,&#13;&#10;        gender&#13;&#10;      } = req.body;&#13;&#10;&#13;&#10;      const user = await User.findByPk(userId);&#13;&#10;      if (!user) {&#13;&#10;        return next(new ApiError('User not found', 404));&#13;&#10;      }&#13;&#10;&#13;&#10;      // Check if phone number is being changed and if it's already taken&#13;&#10;      if (phoneNo &amp;&amp; phoneNo !== user.phoneNo) {&#13;&#10;        const existingUser = await User.findOne({ &#13;&#10;          where: { &#13;&#10;            phoneNo,&#13;&#10;            userId: { [Op.ne]: userId }&#13;&#10;          }&#13;&#10;        });&#13;&#10;        &#13;&#10;        if (existingUser) {&#13;&#10;          return next(new ApiError('Phone number already exists', 400));&#13;&#10;        }&#13;&#10;      }&#13;&#10;&#13;&#10;      const updateData = {};&#13;&#10;      if (name) updateData.name = name;&#13;&#10;      if (dob) updateData.dob = dob;&#13;&#10;      if (phoneNo) updateData.phoneNo = phoneNo;&#13;&#10;      if (gender) updateData.gender = gender;&#13;&#10;&#13;&#10;      await user.update(updateData);&#13;&#10;&#13;&#10;      res.json({&#13;&#10;        success: true,&#13;&#10;        message: 'Profile updated successfully',&#13;&#10;        data: user&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      next(error);&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  // Update profile photo&#13;&#10;  async updateProfilePhoto(req, res, next) {&#13;&#10;    try {&#13;&#10;      const userId = req.user.userId;&#13;&#10;&#13;&#10;      if (!req.file) {&#13;&#10;        return next(new ApiError('No file uploaded', 400));&#13;&#10;      }&#13;&#10;&#13;&#10;      const user = await User.findByPk(userId);&#13;&#10;      if (!user) {&#13;&#10;        return next(new ApiError('User not found', 404));&#13;&#10;      }&#13;&#10;&#13;&#10;      // Convert image to base64&#13;&#10;      const imageBuffer = await fs.readFile(req.file.path);&#13;&#10;      const base64Image = `data:${req.file.mimetype};base64,${imageBuffer.toString('base64')}`;&#13;&#10;&#13;&#10;      // Update user profile photo&#13;&#10;      await user.update({ profilePhoto: base64Image });&#13;&#10;&#13;&#10;      // Delete uploaded file&#13;&#10;      await fs.unlink(req.file.path);&#13;&#10;&#13;&#10;      res.json({&#13;&#10;        success: true,&#13;&#10;        message: 'Profile photo updated successfully',&#13;&#10;        data: {&#13;&#10;          profilePhoto: base64Image&#13;&#10;        }&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      // Clean up uploaded file if error occurs&#13;&#10;      if (req.file) {&#13;&#10;        try {&#13;&#10;          await fs.unlink(req.file.path);&#13;&#10;        } catch (unlinkError) {&#13;&#10;          console.error('Error deleting uploaded file:', unlinkError);&#13;&#10;        }&#13;&#10;      }&#13;&#10;      next(error);&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  // Get user profile photo&#13;&#10;  async getProfilePhoto(req, res, next) {&#13;&#10;    try {&#13;&#10;      const { email } = req.params;&#13;&#10;      &#13;&#10;      const user = await User.findOne({ where: { email } });&#13;&#10;      if (!user || !user.profilePhoto) {&#13;&#10;        return next(new ApiError('Profile photo not found', 404));&#13;&#10;      }&#13;&#10;&#13;&#10;      res.json({&#13;&#10;        success: true,&#13;&#10;        data: {&#13;&#10;          profilePhoto: user.profilePhoto&#13;&#10;        }&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      next(error);&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  // Change password&#13;&#10;  async changePassword(req, res, next) {&#13;&#10;    try {&#13;&#10;      const userId = req.user.userId;&#13;&#10;      const { currentPassword, newPassword } = req.body;&#13;&#10;&#13;&#10;      const user = await User.findByPk(userId);&#13;&#10;      if (!user) {&#13;&#10;        return next(new ApiError('User not found', 404));&#13;&#10;      }&#13;&#10;&#13;&#10;      // Verify current password&#13;&#10;      const isCurrentPasswordValid = await user.comparePassword(currentPassword);&#13;&#10;      if (!isCurrentPasswordValid) {&#13;&#10;        return next(new ApiError('Current password is incorrect', 400));&#13;&#10;      }&#13;&#10;&#13;&#10;      // Update password&#13;&#10;      await user.update({ password: newPassword });&#13;&#10;&#13;&#10;      res.json({&#13;&#10;        success: true,&#13;&#10;        message: 'Password changed successfully'&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      next(error);&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  // Get user dashboard data&#13;&#10;  async getDashboard(req, res, next) {&#13;&#10;    try {&#13;&#10;      const userId = req.user.userId;&#13;&#10;      const today = new Date().toISOString().split('T')[0];&#13;&#10;&#13;&#10;      // Get user habits with today's progress&#13;&#10;      const habits = await Habit.findAll({&#13;&#10;        include: [&#13;&#10;          {&#13;&#10;            model: User,&#13;&#10;            as: 'users',&#13;&#10;            where: { userId },&#13;&#10;            attributes: [],&#13;&#10;            through: { attributes: [] }&#13;&#10;          },&#13;&#10;          {&#13;&#10;            model: HabitProgress,&#13;&#10;            as: 'progress',&#13;&#10;            where: { &#13;&#10;              userId,&#13;&#10;              completionDate: today&#13;&#10;            },&#13;&#10;            required: false&#13;&#10;          }&#13;&#10;        ],&#13;&#10;        where: { isActive: true }&#13;&#10;      });&#13;&#10;&#13;&#10;      // Calculate statistics&#13;&#10;      const totalHabits = habits.length;&#13;&#10;      const completedToday = habits.filter(h =&gt; &#13;&#10;        h.progress.length &gt; 0 &amp;&amp; h.progress[0].completionStatus === 'COMPLETED'&#13;&#10;      ).length;&#13;&#10;&#13;&#10;      // Get weekly progress&#13;&#10;      const weekAgo = new Date();&#13;&#10;      weekAgo.setDate(weekAgo.getDate() - 7);&#13;&#10;&#13;&#10;      const weeklyProgress = await HabitProgress.findAll({&#13;&#10;        where: {&#13;&#10;          userId,&#13;&#10;          completionDate: {&#13;&#10;            [Op.gte]: weekAgo.toISOString().split('T')[0]&#13;&#10;          },&#13;&#10;          completionStatus: 'COMPLETED'&#13;&#10;        },&#13;&#10;        attributes: ['completionDate'],&#13;&#10;        group: ['completionDate'],&#13;&#10;        order: [['completionDate', 'ASC']]&#13;&#10;      });&#13;&#10;&#13;&#10;      // Get current streaks&#13;&#10;      const habitStreaks = habits.map(habit =&gt; ({&#13;&#10;        habitId: habit.habitId,&#13;&#10;        habitName: habit.habitName,&#13;&#10;        currentStreak: habit.currentStreak,&#13;&#10;        longestStreak: habit.longestStreak&#13;&#10;      }));&#13;&#10;&#13;&#10;      res.json({&#13;&#10;        success: true,&#13;&#10;        data: {&#13;&#10;          habits,&#13;&#10;          statistics: {&#13;&#10;            totalHabits,&#13;&#10;            completedToday,&#13;&#10;            completionRate: totalHabits &gt; 0 ? (completedToday / totalHabits * 100).toFixed(2) : 0,&#13;&#10;            weeklyCompletions: weeklyProgress.length&#13;&#10;          },&#13;&#10;          streaks: habitStreaks&#13;&#10;        }&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      next(error);&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  // Get user statistics&#13;&#10;  async getStatistics(req, res, next) {&#13;&#10;    try {&#13;&#10;      const userId = req.user.userId;&#13;&#10;      const { period = '30' } = req.query;&#13;&#10;&#13;&#10;      const startDate = new Date();&#13;&#10;      startDate.setDate(startDate.getDate() - parseInt(period));&#13;&#10;&#13;&#10;      const [&#13;&#10;        totalHabits,&#13;&#10;        completedHabits,&#13;&#10;        habitProgress,&#13;&#10;        categoryStats&#13;&#10;      ] = await Promise.all([&#13;&#10;        // Total active habits&#13;&#10;        Habit.count({&#13;&#10;          include: [{&#13;&#10;            model: User,&#13;&#10;            as: 'users',&#13;&#10;            where: { userId },&#13;&#10;            through: { attributes: [] }&#13;&#10;          }],&#13;&#10;          where: { isActive: true }&#13;&#10;        }),&#13;&#10;&#13;&#10;        // Completed habits in period&#13;&#10;        HabitProgress.count({&#13;&#10;          where: {&#13;&#10;            userId,&#13;&#10;            completionDate: {&#13;&#10;              [Op.gte]: startDate.toISOString().split('T')[0]&#13;&#10;            },&#13;&#10;            completionStatus: 'COMPLETED'&#13;&#10;          }&#13;&#10;        }),&#13;&#10;&#13;&#10;        // Daily progress over period&#13;&#10;        HabitProgress.findAll({&#13;&#10;          where: {&#13;&#10;            userId,&#13;&#10;            completionDate: {&#13;&#10;              [Op.gte]: startDate.toISOString().split('T')[0]&#13;&#10;            }&#13;&#10;          },&#13;&#10;          attributes: [&#13;&#10;            'completionDate',&#13;&#10;            'completionStatus'&#13;&#10;          ],&#13;&#10;          order: [['completionDate', 'ASC']]&#13;&#10;        }),&#13;&#10;&#13;&#10;        // Habit categories statistics&#13;&#10;        Habit.findAll({&#13;&#10;          include: [{&#13;&#10;            model: User,&#13;&#10;            as: 'users',&#13;&#10;            where: { userId },&#13;&#10;            attributes: [],&#13;&#10;            through: { attributes: [] }&#13;&#10;          }],&#13;&#10;          attributes: [&#13;&#10;            'habitCategory',&#13;&#10;            'currentStreak',&#13;&#10;            'longestStreak'&#13;&#10;          ],&#13;&#10;          where: { isActive: true }&#13;&#10;        })&#13;&#10;      ]);&#13;&#10;&#13;&#10;      // Process daily progress&#13;&#10;      const dailyStats = {};&#13;&#10;      habitProgress.forEach(progress =&gt; {&#13;&#10;        const date = progress.completionDate;&#13;&#10;        if (!dailyStats[date]) {&#13;&#10;          dailyStats[date] = { completed: 0, total: 0 };&#13;&#10;        }&#13;&#10;        dailyStats[date].total++;&#13;&#10;        if (progress.completionStatus === 'COMPLETED') {&#13;&#10;          dailyStats[date].completed++;&#13;&#10;        }&#13;&#10;      });&#13;&#10;&#13;&#10;      // Process category statistics&#13;&#10;      const categoryBreakdown = {};&#13;&#10;      categoryStats.forEach(habit =&gt; {&#13;&#10;        const category = habit.habitCategory;&#13;&#10;        if (!categoryBreakdown[category]) {&#13;&#10;          categoryBreakdown[category] = {&#13;&#10;            count: 0,&#13;&#10;            totalCurrentStreak: 0,&#13;&#10;            maxStreak: 0&#13;&#10;          };&#13;&#10;        }&#13;&#10;        categoryBreakdown[category].count++;&#13;&#10;        categoryBreakdown[category].totalCurrentStreak += habit.currentStreak;&#13;&#10;        categoryBreakdown[category].maxStreak = Math.max(&#13;&#10;          categoryBreakdown[category].maxStreak,&#13;&#10;          habit.longestStreak&#13;&#10;        );&#13;&#10;      });&#13;&#10;&#13;&#10;      res.json({&#13;&#10;        success: true,&#13;&#10;        data: {&#13;&#10;          period: parseInt(period),&#13;&#10;          overview: {&#13;&#10;            totalHabits,&#13;&#10;            completedHabits,&#13;&#10;            completionRate: totalHabits &gt; 0 ? (completedHabits / (totalHabits * parseInt(period)) * 100).toFixed(2) : 0&#13;&#10;          },&#13;&#10;          dailyProgress: dailyStats,&#13;&#10;          categoryBreakdown,&#13;&#10;          generatedAt: new Date().toISOString()&#13;&#10;        }&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      next(error);&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  // Delete user account&#13;&#10;  async deleteAccount(req, res, next) {&#13;&#10;    try {&#13;&#10;      const userId = req.user.userId;&#13;&#10;      const { password } = req.body;&#13;&#10;&#13;&#10;      const user = await User.findByPk(userId);&#13;&#10;      if (!user) {&#13;&#10;        return next(new ApiError('User not found', 404));&#13;&#10;      }&#13;&#10;&#13;&#10;      // Verify password before deletion&#13;&#10;      const isPasswordValid = await user.comparePassword(password);&#13;&#10;      if (!isPasswordValid) {&#13;&#10;        return next(new ApiError('Password is incorrect', 400));&#13;&#10;      }&#13;&#10;&#13;&#10;      // Delete user data&#13;&#10;      await HabitProgress.destroy({ where: { userId } });&#13;&#10;      &#13;&#10;      // Remove user from habits&#13;&#10;      const userHabits = await user.getHabits();&#13;&#10;      await user.removeHabits(userHabits);&#13;&#10;&#13;&#10;      // Delete user&#13;&#10;      await user.destroy();&#13;&#10;&#13;&#10;      res.json({&#13;&#10;        success: true,&#13;&#10;        message: 'Account deleted successfully'&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      next(error);&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  // Export multer upload middleware&#13;&#10;  static getUploadMiddleware() {&#13;&#10;    return upload.single('profilePhoto');&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;module.exports = new UserController();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HabitUPMigration247-master/routes/user.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HabitUPMigration247-master/routes/user.js" />
              <option name="originalContent" value="const express = require('express');&#10;const { body, param, validationResult } = require('express-validator');&#10;const userController = require('../controllers/userController');&#10;const { authorize } = require('../middleware/auth');&#10;const router = express.Router();&#10;&#10;// Middleware to handle validation errors&#10;const handleValidationErrors = (req, res, next) =&gt; {&#10;  const errors = validationResult(req);&#10;  if (!errors.isEmpty()) {&#10;    return res.status(400).json({&#10;      success: false,&#10;      message: 'Validation Error',&#10;      errors: errors.array()&#10;    });&#10;  }&#10;  next();&#10;};&#10;&#10;// Get current user profile&#10;router.get('/profile', authorize, userController.getCurrentUser);&#10;&#10;// Get user dashboard&#10;router.get('/dashboard', userController.getDashboard);&#10;&#10;// Get user statistics&#10;router.get('/statistics', userController.getStatistics);&#10;&#10;// Update user profile&#10;router.put('/profile', [&#10;  body('name').optional().isLength({ min: 2 }).withMessage('Name must be at least 2 characters'),&#10;  body('phoneNo').optional().isLength({ min: 10 }).withMessage('Phone number must be at least 10 digits'),&#10;  body('gender').optional().isIn(['MALE', 'FEMALE', 'OTHER']).withMessage('Invalid gender'),&#10;  body('dob').optional().isDate().withMessage('Invalid date of birth'),&#10;  handleValidationErrors&#10;], userController.updateProfile);&#10;&#10;// Update profile photo&#10;router.put('/profile/photo', &#10;  userController.constructor.getUploadMiddleware(),&#10;  userController.updateProfilePhoto&#10;);&#10;&#10;// Get profile photo by email&#10;router.get('/profile-photo/:email', [&#10;  param('email').isEmail().withMessage('Invalid email format'),&#10;  handleValidationErrors&#10;], userController.getProfilePhoto);&#10;&#10;// Change password&#10;router.put('/password', [&#10;  body('currentPassword').notEmpty().withMessage('Current password is required'),&#10;  body('newPassword').isLength({ min: 6 }).withMessage('New password must be at least 6 characters'),&#10;  handleValidationErrors&#10;], userController.changePassword);&#10;&#10;// Delete user account&#10;router.delete('/account', [&#10;  body('password').notEmpty().withMessage('Password is required for account deletion'),&#10;  handleValidationErrors&#10;], userController.deleteAccount);&#10;&#10;module.exports = router;&#10;" />
              <option name="updatedContent" value="const express = require('express');&#13;&#10;const { body, param, validationResult } = require('express-validator');&#13;&#10;const userController = require('../controllers/userController');&#13;&#10;const { authorize } = require('../middleware/auth');&#13;&#10;const router = express.Router();&#13;&#10;&#13;&#10;// Middleware to handle validation errors&#13;&#10;const handleValidationErrors = (req, res, next) =&gt; {&#13;&#10;  const errors = validationResult(req);&#13;&#10;  if (!errors.isEmpty()) {&#13;&#10;    return res.status(400).json({&#13;&#10;      success: false,&#13;&#10;      message: 'Validation Error',&#13;&#10;      errors: errors.array()&#13;&#10;    });&#13;&#10;  }&#13;&#10;  next();&#13;&#10;};&#13;&#10;&#13;&#10;// Get current user profile&#13;&#10;router.get('/profile', authorize, userController.getCurrentUser);&#13;&#10;&#13;&#10;// Get user dashboard&#13;&#10;router.get('/dashboard', userController.getDashboard);&#13;&#10;&#13;&#10;// Get user statistics&#13;&#10;router.get('/statistics', userController.getStatistics);&#13;&#10;&#13;&#10;// Update user profile&#13;&#10;router.put('/profile', [&#13;&#10;  body('name').optional().isLength({ min: 2 }).withMessage('Name must be at least 2 characters'),&#13;&#10;  body('phoneNo').optional().isLength({ min: 10 }).withMessage('Phone number must be at least 10 digits'),&#13;&#10;  body('gender').optional().isIn(['MALE', 'FEMALE', 'OTHER']).withMessage('Invalid gender'),&#13;&#10;  body('dob').optional().isDate().withMessage('Invalid date of birth'),&#13;&#10;  handleValidationErrors&#13;&#10;], userController.updateProfile);&#13;&#10;&#13;&#10;// Update profile photo&#13;&#10;router.put('/profile/photo', &#13;&#10;  userController.constructor.getUploadMiddleware(),&#13;&#10;  userController.updateProfilePhoto&#13;&#10;);&#13;&#10;&#13;&#10;// Get profile photo by email&#13;&#10;router.get('/profile-photo/:email', [&#13;&#10;  param('email').isEmail().withMessage('Invalid email format'),&#13;&#10;  handleValidationErrors&#13;&#10;], userController.getProfilePhoto);&#13;&#10;&#13;&#10;// Change password&#13;&#10;router.put('/password', [&#13;&#10;  body('currentPassword').notEmpty().withMessage('Current password is required'),&#13;&#10;  body('newPassword').isLength({ min: 6 }).withMessage('New password must be at least 6 characters'),&#13;&#10;  handleValidationErrors&#13;&#10;], userController.changePassword);&#13;&#10;&#13;&#10;// Delete user account&#13;&#10;router.delete('/account', [&#13;&#10;  body('password').notEmpty().withMessage('Password is required for account deletion'),&#13;&#10;  handleValidationErrors&#13;&#10;], userController.deleteAccount);&#13;&#10;&#13;&#10;module.exports = router;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>